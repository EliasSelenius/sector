

// struct QuadTreeNode {
//     QuadTreeNode* q1, q2, q3, q4;
//     Entity* e;
// }

// QuadTreeNode* insert(QuadTreeNode* node, vec2 pos, float32 size, Entity* e) {
//     if node == null  node = alloc QuadTreeNode;
//     if node.e {
//     }
//     node.e = e;
// }




// Arena* arean_entities = arena_create();
// uint32 entities_count = 0;
// Entity* spawn() {
//     Entity* en = arena_alloc(arean_entities, sizeof Entity);

//     entities_count++;
//     return en;
// }

// removes dead entities and defragments arena while retaining correct parent pointer for dead/relocated parent entities
// void cleanup_entities() {
//     Entity* entities = arean_entities as uint64 + sizeof(Arena);

//     for 0 .. entities_count {
//         let en = *entities[it];
//         if en.parent and is_dead(en.parent) en.parent = null;
//     }

//     for 0 .. entities_count {
//         let en = *entities[it];
//         if is_dead(en) {
//             let last_en = *entities[entities_count-1];
//             @en = @last_en;
//             @(last_en as uint32*) = it;
//             entities_count--;
//             it--;
//         }
//     }

//     for 0 .. entities_count {
//         let en = *entities[it];
//         if en.parent {
//             if en.parent as uint64 >= *entities[entities_count] as uint64 {
//                 en.parent = *entities[@(en.parent as uint32*)];
//             }
//         }
//     }

// }



struct EntityPool {
    Entity* data;
    uint32 count;
}

EntityPool init_pool() {
    return {
        data = vmem_reserve(0xFFFF_FFFF)
    };
}

Entity* entity_new(EntityPool* pool) {
    for 0 .. pool.count {
        let en = *pool.data[it];
        // TODO: error: Cannot infer implicit dereferencing ".ready_for_reuse".
        // we should be able to use implicit dereferencing here
        if en.entity_type == EntityType.ready_for_reuse  return en;
    }

    // TODO: should vmem_commit be wrapped in a condition for performance?
    vmem_commit(pool.data, ++pool.count * sizeof Entity);
    return *pool.data[pool.count-1];
}

void cleanup_pool(EntityPool* pool) {
    for 0 .. pool.count {
        let en = *pool.data[it];
        if en.parent and is_dead(en.parent) en.parent = null;
        if en.target and is_dead(en.target) en.target = null;

        if is_dead(en) en.entity_type = .ready_for_reuse;
    }

    uint32 i = pool.count;
    while i {
        let en = *pool.data[--i];
        if is_dead(en)  pool.count--;
        else break;
    }
}


const do_enemy_spawn = false;
const linear_drag = 0.99;

EntityPool entity_pool = init_pool();
Entity* player;


const team_id_asteroids = 0;
const team_id_player = 1;

Bullet* bullets = list_create(sizeof Bullet);

Transform2D camera = {0,0, 0, 10};

struct SpaceshipType {
    char* name;
    vec2[] thrusters;
    vec2[] turret_mount;

    uint32 sprite_index;
    Sprite sprite;

    uint32 cargo_capacity;
}

SpaceshipType[] spaceship_types = {
    { name = "og",          thrusters = {}, sprite_index = 4, cargo_capacity = 40 },
    { name = "new",         thrusters = {}, sprite_index = 3, cargo_capacity = 50 },
    { name = "large_agile", thrusters = {}, sprite_index = 5, cargo_capacity = 35 },
    { name = "moth",        thrusters = {}, sprite_index = 6, cargo_capacity = 150 },
    { name = "idunno",      thrusters = {}, sprite_index = 7, cargo_capacity = 70 }
};

enum Agent_Behaviour {
    follow; attack;
}

enum EntityType {
    none; // default no behaviour
    ready_for_reuse;
    ship; turret;
    station; asteroid;
    item;
}

enum EntityEvent {
    spawned; despawned;
    damage_taken;
}

struct Entity {
    Entity* parent, target;
    void(Entity*) behaviour;
    void(Entity*, EntityEvent, void*) event;

    EntityType entity_type;

    with Transform2D tr;
    float32 depth;

    Sprite sprite;

    vec2 vel;
    float32 ang_vel;
    float32 mass;

    uint32 hp, max_hp;
    uint32 team_id;
    uint32 cargo_capacity;
    float32 cooldown;
    float32 collider_radius;

    Cargo* cargo;
    Item item;
}

struct Bullet {
    vec2 pos;
    vec2 vel;
    uint32 team_id;
}

void spawn_bullet(vec2 pos, vec2 vel, uint32 team_id) {
    Bullet p = {pos, vel, team_id};
    list_add(*bullets, *p);
}


bool is_dead(Entity* e) { return e.hp == 0; }

void despawn(Entity* en) {
    en.hp = 0;
    if en.cargo  free(en.cargo);
}

// initializes entity data with sensible defaults, some based on sprite
Entity* spawn_entity(EntityPool* pool, vec2 pos, Sprite sprite) {
    let en = entity_new(pool);
    @en = {};
    en.tr.pos = pos;
    en.tr.scale = 1;
    en.sprite = sprite;

    let size = get_boundingbox_size(get_sprite_boundingbox(sprite));
    en.collider_radius = min(size.x, size.y) * en.tr.scale / 2;

    en.max_hp = (size.x + size.y) / 20;
    en.hp = en.max_hp;
    en.mass = size.x * size.y;
    return en;
}

Entity* spawn_ship(vec2 pos, uint32 ship_type) {
    let sst = spaceship_types[ship_type];

    let en = spawn_entity(*entity_pool, pos, sst.sprite);
    en.entity_type = .ship;

    en.max_hp *= 6;
    en.hp = en.max_hp;

    en.tr.rot = random(global_seed++) * Pi;
    en.cargo_capacity = sst.cargo_capacity;
    return en;
}

Entity* spawn_player() {
    let en = spawn_ship(vec2_zero, 0);
    en.team_id = team_id_player;

    let turret = spawn_entity(*entity_pool, vec2_zero, sprite_turret);
    turret.entity_type = .turret;
    turret.parent = en;

    return en;
}

Entity* spawn_enemy(vec2 pos) {
    static uint32 ships_index = 0;
    static uint32 team_id = 3;

    let en = spawn_ship(pos, ships_index++ % spaceship_types.length);
    en.team_id = team_id++;
    en.behaviour = update_ai;
    return en;
}

Entity* spawn_asteroid(EntityPool* pool, vec2 pos, uint32 asteroid_index) {

    let sprite = sprites_asteroids[asteroid_index];
    let en = spawn_entity(pool, pos, sprite);
    en.entity_type = .asteroid;

    en.tr.rot = random(global_seed++) * Pi;
    en.team_id = team_id_asteroids;
    en.depth = 0.01;

    return en;
}

Entity* spawn_item(vec2 pos, ItemKind item_kind, uint32 count) return spawn_item(pos, { item_kind, count } as Item);
Entity* spawn_item(vec2 pos, Item item) {
    let en = spawn_entity(*entity_pool, pos, sprites_items[item.kind]);
    en.entity_type = .item;
    en.item = item;
    return en;
}

void accelerate(Entity* e, vec2 acc) {
    e.vel = add(e.vel, mul(acc, deltatime()));
}

void apply_impulse(Entity* en, vec2 impulse) {
    en.vel = en.vel + impulse / en.mass;
}

// note: |dir.x| <= 1 and |dir.y| <= 1
void thrust(Entity* e, vec2 dir) {
    if dir.x == 0.0 and dir.y == 0.0 return;

    const non_forward_factor = 0.7;
    dir.x *= non_forward_factor;
    if dir.y < 0  dir.y *= non_forward_factor;
    dir = rotate_vec(dir, e.tr.rot);

    let dt = deltatime();

    let force = dir * e.mass * 80; // * 80_000; // N
    let imp = force * dt;     // Ns
    apply_impulse(e, imp);

    let sprite_size = get_sprite_size(e.sprite);
    vec2 offset = {0, -sprite_size.y / 2};
    vec2 particle_pos = local2world(e.tr, offset);

    let P_vel = e.vel - dir * 8000 * dt;
    spawn_particle(particle_pos, P_vel, 0.5, 1, 0.5, 2.0);
}

void turn_to(Entity* e, vec2 target) {
    let diff = sub(target, e.tr.pos);
    diff = rotate_vec(diff, -e.tr.rot);
    float32 angle = vec2_to_angle(diff);

    e.ang_vel = angle * 3;
}

void fire_gun(Entity* e) {
    if e.cooldown <= 0 {
        let disp = up(e.tr);
        disp.x *= -1;

        let vel = add(mul(disp, 50*16), e.vel);
        vel = add(vel, random_vec2(3*16));
        spawn_bullet(add(e.tr.pos, disp), vel, e.team_id);
        e.cooldown = 0.25;
    }
}

void on_destroy(Entity* en) {

    if en.cargo  drop_cargo(en, 0);

    switch en.entity_type {
        case .ship: {
            spawn_explosion((en.collider_radius * 5) as uint32, en.tr.pos, en.vel, 7*16);
        } break;
        case .turret: {
            spawn_explosion((en.collider_radius * 5) as uint32, en.tr.pos, en.vel, 7*16);
        } break;

        case .station: break;
        case .asteroid: {
            let asteroid_index = en.sprite.bb_index; // TODO: hack! bb_index happens to be equal the asteroid_index. Maybe Entity could have a uint32 level; that would be an agnostic field
            if asteroid_index {
                for 0 .. 2 {
                    let a = spawn_asteroid(*entity_pool, en.tr.pos, asteroid_index - 1);
                    a.vel = a.vel + en.vel + random_unit_vec2() * 50;
                    a.ang_vel = random(global_seed++) * Pi;
                }
            } else {
                let drop_count = random_range(global_seed++, 0, 7) as uint32;
                for 0 .. drop_count {
                    let a = spawn_item(en.tr.pos, ItemKind.Rock, 1);
                    a.vel = a.vel + en.vel + random_unit_vec2() * 50;
                    a.ang_vel = random(global_seed++) * Pi;
                }
            }

            spawn_explosion((en.collider_radius * 5) as uint32, en.tr.pos, en.vel, 7*16);
        } break;

        case .item: {
        } break;
    }
}

void update_entity(Entity* en) {
    let dt = deltatime();
    en.tr.pos = en.tr.pos + en.vel * dt;
    en.tr.rot += en.ang_vel * dt;
    en.vel = en.vel * linear_drag;
    en.ang_vel *= 0.99;

    if en.cooldown > 0  en.cooldown -= dt;
    if en.behaviour  en.behaviour(en);

    if en.parent  en.tr.pos = local2world(en.parent.tr, vec2_zero);

    switch en.entity_type {
        case .item: {
            if en.cooldown <= 0 {
                let picker = closest_entity(en, EntityType.ship);
                if picker and entity_intersects(en, picker) pickup(picker, en);
            }

        } break;

        default: break;
    }

    vec4 color = vec4_zero;

    for 0 .. list_length(bullets) {
        let bullet = bullets[it];
        if bullet.team_id == en.team_id continue;

        float32 intersection = circle_dist(en.tr.pos, en.collider_radius, bullet.pos, 0.3);
        if intersection < 0 {
            color = {1, 1, 1, 1};
            en.hp--;
            apply_impulse(en, bullet.vel);

            if en == player  this_frame.player_took_damage = true;

            list_unordered_remove(bullets, it-- as uint32);

            if is_dead(en) {
                on_destroy(en);
                break;
            }
        }
    }

    draw_sprite(en.tr, en.depth, en.sprite, vec4_one, color);
}

void update_ai(Entity* en) {

    if en.target == null {
        en.target = closest_entity(en, EntityType.ship);
        if en.target == null  return;
    }


    turn_to(en, en.target.tr.pos);
    let dist = length(sub(en.tr.pos, en.target.tr.pos));

    if dist < 15*16  fire_gun(en);

    let t = dist - 5*16;
    t = t / abs(t);
    thrust(en, { 0, t } as vec2);
}

float32 circle_dist(vec2 p0, float32 r0, vec2 p1, float32 r1) {
    let len = length(sub(p0, p1));
    let r = r0 + r1;
    return len - r;
}

float32 entity_intersects(Entity* e0, e1) return circle_dist(e0.tr.pos, e0.collider_radius, e1.tr.pos, e1.collider_radius) < 0;

Entity* query_entity(vec2 pos) {
    for 0 .. entity_pool.count {
        let e = *entity_pool.data[it];
        if !is_dead(e) and circle_dist(pos, 0, e.tr.pos, e.collider_radius) < 0   return e;
    }

    return null;
}

Entity* closest_entity(Entity* self, EntityType et) {
    float32 min_sqdist = 99999999;
    Entity* result = null;

    for 0 .. entity_pool.count {
        let en = *entity_pool.data[it];
        if en == self or is_dead(en) or en.entity_type != et  continue;

        float32 sqd = sqdist(self.tr.pos, en.tr.pos);
        if sqd < min_sqdist {
            result = en;
            min_sqdist = sqd;
        }
    }

    return result;
}

void update_world() {
    let dt = deltatime();

    if player and is_dead(player)   player = null;

    if key_pressed(GLFW_KEY_SPACE)  player = null;

    { // camera controlls:
        static vec2 target_cam_pos = {};
        static float32 target_cam_zoom = 160;

        target_cam_zoom = clamp(target_cam_zoom - target_cam_zoom*0.1*Input.mouse_scroll, 160, 1000);
        float32 target_cam_scale = target_cam_zoom;

        if player {
            target_cam_pos = player.tr.pos;
            target_cam_scale += length(player.vel) / 7;
        } else {
            target_cam_pos = target_cam_pos + Input.wasd * target_cam_zoom / 100;
        }

        camera.pos = exp_decay(camera.pos, target_cam_pos, 4, dt);
        camera.scale = exp_decay(camera.scale, target_cam_scale, 5, dt);
    }

    vec2 mouse_world_pos = get_mouse_world_coord(camera);
    apply_camera(camera);


    if player {
        thrust(player, Input.wasd);
        turn_to(player, mouse_world_pos);
        if mouse(Left_Mouse) fire_gun(player);

        if key_pressed('Q') drop_cargo(player, 5);

        // const font_size = 0.1;
        // vec2 pos = {-1, 1 - font_size / 2};
        // pos = draw_text(pos, font_size, to_string(player.hp as uint64), White);
        // pos = draw_text(pos, font_size, " / ", White);
        // pos = draw_text(pos, font_size, to_string(player_max_hp), White);
    } else {
        // player = spawn_player();
    }


    if mouse_pressed(Right_Mouse) {
        let e = spawn_enemy(mouse_world_pos);
        // let vel = mul(make_vec((mouse_x - pmouse_x) as float32, -(mouse_y - pmouse_y) as float32), 0.01);

        // spawn_explosion(64, mouse_world_pos, vec2_zero, 7*16.0);

        // spawn_item(mouse_world_pos, { ItemKind.Rock, 3 } as Item);
    }

    if mouse_pressed(Left_Mouse) and key(GLFW_KEY_LEFT_SHIFT) {
        let en = query_entity(mouse_world_pos);
        if en and en.entity_type == EntityType.ship {
            en.behaviour = null;
            en.team_id = team_id_player;
            player = en;
        }
    }

    draw_background(camera.pos);

    if player {
        ivec2 chunk_coord = get_chunk_coord(player.tr.pos);

        ivec2[] chunk_coord_offsets = { {0, 0}, {1, 0}, {0, 1}, {1, 1} };
        Chunk*[] chunks = {*chunk_1, *chunk_2, *chunk_3, *chunk_4};
        int32 coord_index = 0;
        ivec2[] coords = {{},{},{},{}};

        for it : 0 .. 4 {
            ivec2 coord = add(chunk_coord, chunk_coord_offsets[it]);

            if      equals(coord, chunk_1.coord) { chunks[0] = null; continue; }
            else if equals(coord, chunk_2.coord) { chunks[1] = null; continue; }
            else if equals(coord, chunk_3.coord) { chunks[2] = null; continue; }
            else if equals(coord, chunk_4.coord) { chunks[3] = null; continue; }
            else {
                coords[coord_index++] = coord;
            }
        }

        coord_index = 0;
        for 0 .. chunks.length {
            if chunks[it] == null  continue;

            spawn_chunk(chunks[it], coords[coord_index++]);
        }
    }



    void update_entity_list(EntityPool* pool) {
        for 0 .. pool.count {
            let e = *pool.data[it];
            if is_dead(e) continue;
            update_entity(e);
        }
    }

    update_entity_list(*entity_pool);
    update_entity_list(*chunk_1.entity_pool);
    update_entity_list(*chunk_2.entity_pool);
    update_entity_list(*chunk_3.entity_pool);
    update_entity_list(*chunk_4.entity_pool);

    cleanup_pool(*entity_pool);
    cleanup_pool(*chunk_1.entity_pool);
    cleanup_pool(*chunk_2.entity_pool);
    cleanup_pool(*chunk_3.entity_pool);
    cleanup_pool(*chunk_4.entity_pool);


    bind(projectile);
    for 0 .. list_length(bullets) {
        let bullet = *bullets[it];

        const despawn_radius = 400;
        if player and sqdist(player.tr.pos, bullet.pos) > (despawn_radius*despawn_radius) {
            list_unordered_remove(bullets, it as uint32);
            it--;
            continue;
        }

        Transform2D tr = { bullet.pos, vec2_to_angle(bullet.vel), 0.1 };
        apply_transform(tr);

        vec2 particle_scale = {4, 16}; // TODO: hard coded dimentions here
        apply_entity_scale(particle_scale);
        apply_uv(vec2_zero, vec2_one);
        draw_elements(quad_db);

        // draw_texture(tr, 0.0, projectile, vec4_one);

        bullet.pos = add(bullet.pos, mul(bullet.vel, deltatime()));
    }


    static uint32 prev_bullets_count = 0;
    uint32 bullets_count = list_length(bullets);
    if bullets_count != prev_bullets_count {
        // print("Bullets: ", bullets_count, "\n");
        prev_bullets_count = bullets_count;
    }


    update_particles();

}

void draw_background(vec2 center) {
    const s = 10;
    const spacing = 160;
    for x : -s .. s+1 for y : -s .. s+1 {
        ivec2 p_seed = make_ivec(round2multiple(center, spacing));
        p_seed.x += x * spacing; p_seed.y += y * spacing;

        int32 seed = p_seed.x + p_seed.y * 100;

        float32 depth = map(random(seed++), -1, 1, 0.3, 1.0);
        Transform2D tr = {};
        tr.pos = add(make_vec(p_seed), mul(make_vec(random(seed++), random(seed++)), spacing / 2.0));
        tr.rot = random(seed++) * Pi;
        tr.scale = 1.0;

        draw_sprite(tr, depth, sprites_asteroids[(random01(seed++) * sprites_asteroids_count) as uint32]);
    }
}

const chunk_size = 1600;

Chunk chunk_1 = init_chunk();
Chunk chunk_2 = init_chunk();
Chunk chunk_3 = init_chunk();
Chunk chunk_4 = init_chunk();


struct Chunk {
    ivec2 coord;
    EntityPool entity_pool;
}

ivec2 get_chunk_coord(vec2 pos) {
    return make_ivec(mul(round2multiple(pos, chunk_size), 1.0 / chunk_size));
}

Chunk init_chunk() {
    Chunk s = {};
    s.coord = {999, 999}; // NOTE: this is to fix bug where chunk 0,0 wont generate at game start
    s.entity_pool = init_pool();
    return s;
}

void spawn_chunk(Chunk* chunk, ivec2 coord) {
    chunk.coord = coord;
    chunk.entity_pool.count = 0;

    int32 seed = (coord.x & 0x0000FFFF) |
                ((coord.y << 16) & 0xFFFF0000);

    print("spawn chunk ", coord, " with seed: ", seed, "\n");

    const half = chunk_size / 2;
    vec2 chunk_pos = make_vec(sub(mul(coord, chunk_size), { half, half } as ivec2));


    // init interactable asteroids
    for 0 .. chunk_size*chunk_size / 10_000 {

        uint32 asteroid_index = (random01(seed++) * sprites_asteroids_count) as uint32;
        vec2 pos = { random(seed++) * half, random(seed++) * half };
        let en = spawn_asteroid(*chunk.entity_pool, pos + chunk_pos, asteroid_index);
        en.tr.rot = random(seed++) * Pi;
        en.depth = 0.01;
    }


    if do_enemy_spawn and random(global_seed++) < 0 {
        vec2 pos = { random(seed++) * half, random(seed++) * half };
        spawn_enemy(pos + chunk_pos);
    }
}