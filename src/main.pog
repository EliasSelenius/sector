
include "../grax/grax.pog";

include "src/world.pog";
include "src/particles.pog";
include "src/inventory.pog";

// ..\plang\bin\plang.exe src\main.pog cflags -lglfw3dll
// ..\plang\bin\plang.exe src\main.pog cflags -lglfw3dll -O0 -g -fsanitize=address -fno-omit-frame-pointer

/*
    Civilization is flourishing in an asteroid field of abundant riches, and yet conflict is prevalent
*/

/* TODOs:
    - cargo inventory
        - asteroids drop minerals
        - ships drop cargo hold

    - we probably need transparancy sorting because how else do we do alpha blending with transparent objects/particles/dustclouds
    - small velocity for sub-particles
    - dust particles for asteroid break
    - bullet impact particles
    - spaceship debrie on destruction

Priority:
    - asteroids break into smaller asteroids





research audio implementations:
    - raylib source code
    - handmade hero?
        - direct sound
        - x audio
    - sokol audio

*/

void apply_camera(Transform2D t) {
    glUniform1f(glGetUniformLocation(default2d_shader.gl_handle, "zoom"), t.scale);
    glUniform2f(glGetUniformLocation(default2d_shader.gl_handle, "cam_pos"), t.pos.x, t.pos.y);
    glUniform1f(glGetUniformLocation(default2d_shader.gl_handle, "cam_rot"), t.rot);
}

void apply_transform(Transform2D t) { apply_transform(t, 0); }
void apply_transform(Transform2D t, float32 depth) {
    glUniform3f(glGetUniformLocation(default2d_shader.gl_handle, "entity_pos"), t.pos.x, t.pos.y, depth);
    glUniform1f(glGetUniformLocation(default2d_shader.gl_handle, "entity_rot"), t.rot);
    glUniform2f(glGetUniformLocation(default2d_shader.gl_handle, "entity_scale"), t.scale, t.scale);
}

void apply_color(vec4 v) glUniform4f(glGetUniformLocation(default2d_shader.gl_handle, "color_factor"), v.x, v.y, v.z, v.w);
void apply_entity_scale(vec2 scale) glUniform2f(glGetUniformLocation(default2d_shader.gl_handle, "entity_scale"), scale.x, scale.y);

void apply_uv(vec2 uv_offset, uv_scale) {
    glUniform2f(glGetUniformLocation(default2d_shader.gl_handle, "uv_offset"), uv_offset.x, uv_offset.y);
    glUniform2f(glGetUniformLocation(default2d_shader.gl_handle, "uv_scale"), uv_scale.x, uv_scale.y);
}

void draw_texture(Transform2D tr, float32 depth, Texture2D tex, vec4 color) draw_texture(tr, depth, tex, {ivec2_zero, {tex.width-1, tex.height-1}} as Image_Boundingbox, color);
void draw_texture(Transform2D tr, float32 depth, Texture2D tex, Image_Boundingbox bb, vec4 color) {
    apply_color(color);
    apply_transform(tr, depth);

    vec2 uv_offset = {};
    vec2 uv_scale = {};
    ivec2 size = get_boundingbox_size(bb);
    uv_scale.x = size.x / tex.width as float32;
    uv_scale.y = size.y / tex.height as float32;
    uv_offset.x = bb.min.x / tex.width as float32;
    uv_offset.y = bb.min.y / tex.height as float32;

    apply_entity_scale(make_vec(size.x * tr.scale, size.y * tr.scale));
    apply_uv(uv_offset, uv_scale);
    bind(tex);
    draw_elements(quad_db);
}

void draw_sprite(Transform2D tr, float32 depth, Sprite sprite, vec4 color) {
    draw_texture(tr, depth, sprite.sheet.texture, get_sprite_boundingbox(sprite), color);
}


vec2 get_mouse_world_coord(Transform2D cam_tr) {
    float32 x = mouse_x as float32 / app.window_width * 2 - 1;
    float32 y = -(mouse_y as float32 / app.window_height * 2 - 1);

    x *= app.width_over_height;

    return local2world(cam_tr, x, y);
}


struct Spritesheet {
    Image_Boundingbox* regions; // list
    Texture2D texture;
}

struct Sprite {
    Spritesheet* sheet;
    uint32 bb_index;
}

Image_Boundingbox get_sprite_boundingbox(Sprite sprite) return sprite.sheet.regions[sprite.bb_index];
ivec2 get_sprite_size(Sprite s) return get_boundingbox_size(get_sprite_boundingbox(s));

Sprite get_sprite(with Spritesheet* sheet, uint32 index) {
    Sprite s = {};
    s.sheet = sheet;
    s.bb_index = index;
    return s;
}



DrawBuffers quad_db;

Texture2D projectile;
Texture2D particle;

Spritesheet spritesheet;

const sprites_asteroids_count = 3;
Sprite[3] sprites_asteroids;

Sprite sprite_turret;

void loadassets() {
    projectile = load_texture2D("assets/proj.bmp");
    particle   = load_texture2D("assets/particle.bmp");


    Spritesheet load_spritesheet(char* file_name) {
        let image = load_bitmap(file_name);
        Spritesheet sheet = {};

        sheet.texture = create_texture2D(image);
        set_filter(sheet.texture, TextureFilter.nearest);

        sheet.regions = get_all_regions(image);

        free(image.pixels);
        return sheet;
    }

    spritesheet = load_spritesheet("assets/spritesheet.bmp");

    for 0 .. spaceship_types.length {
        spaceship_types[it].sprite = get_sprite(*spritesheet, spaceship_types[it].sprite_index);
    }

    for 0 .. sprites_asteroids_count {
        sprites_asteroids[it] = get_sprite(*spritesheet, it);
    }

    sprite_turret = get_sprite(*spritesheet, 8);
}

void on_event(AppEvent event, AppEventData data) switch event {

}

void main() {
    grax_init();
    app.on_event = on_event;

    loadassets();

    quad_db = create_draw_buffers();
    {
        float32 p = 0.5;
        vertex2D[] verts = {
            {-p, -p, 0, 0, White},
            { p, -p, 1, 0, White},
            { p,  p, 1, 1, White},
            {-p,  p, 0, 1, White}
        };

        uint32[] inds = {
            0, 1, 2,
            0, 2, 3
        };
        update_buffers(*quad_db, verts, inds);
    }

    set_clear_color(rgba(0x0a0a0aff));

    while grax_loop() {
        use(*default2d_shader);
        enable_alpha_blending();
        enable_depth_test();

        update_world();
    }
}
