
include "../grax/grax.pog";

include "src/world.pog";
include "src/particles.pog";
include "src/inventory.pog";

// ..\plang\bin\plang.exe src\main.pog cflags -lglfw3dll
// ..\plang\bin\plang.exe src\main.pog cflags -lglfw3dll -O0 -g -fsanitize=address -fno-omit-frame-pointer

/*
    Civilization is flourishing in an asteroid field of abundant riches, and yet conflict is prevalent
*/

/* TODOs:
    - cargo inventory
        - asteroids drop minerals
        - ships drop cargo hold

    - we probably need transparancy sorting because how else do we do alpha blending with transparent objects/particles/dustclouds
    - small velocity for sub-particles
    - dust particles for asteroid break
    - bullet impact particles
    - bullet particle trail
    - spaceship debrie on destruction
    - cargo capacity and health bar
        - animate with exp_decay, flash and size increase

Priority:
    - asteroids break into smaller asteroids





research audio implementations:
    - raylib source code
    - handmade hero?
        - direct sound
        - x audio
    - sokol audio

*/

void apply_camera(Transform2D t) {
    set_uniform("zoom", t.scale);
    set_uniform("cam_pos", t.pos.x, t.pos.y);
    set_uniform("cam_rot", t.rot);
}

void apply_transform(Transform2D t) { apply_transform(t, 0); }
void apply_transform(Transform2D t, float32 depth) {
    set_uniform("entity_pos", t.pos.x, t.pos.y, depth);
    set_uniform("entity_rot", t.rot);
    set_uniform("entity_scale", t.scale, t.scale);
}

void apply_colors(vec4 factor, additive) {
    set_uniform("color_factor", factor);
    set_uniform("color_additive", additive);
}

void apply_entity_scale(vec2 scale) {
    set_uniform("entity_scale", scale);
}

void apply_uv(vec2 uv_offset, uv_scale) {
    set_uniform("uv_offset", uv_offset);
    set_uniform("uv_scale", uv_scale);
}

void draw_texture(Transform2D tr, float32 depth, Texture2D tex, vec4 color_factor, color_additive) {
    Image_Boundingbox bb = {ivec2_zero, {tex.width-1, tex.height-1}};
    draw_texture(tr, depth, tex, bb, color_factor, color_additive);
}

void draw_texture(Transform2D tr, float32 depth, Texture2D tex, Image_Boundingbox bb, vec4 color_factor, color_additive) {
    vec2 uv_offset = {};
    vec2 uv_scale = {};
    ivec2 size = get_boundingbox_size(bb);
    uv_scale.x = size.x / tex.width as float32;
    uv_scale.y = size.y / tex.height as float32;
    uv_offset.x = bb.min.x / tex.width as float32;
    uv_offset.y = bb.min.y / tex.height as float32;

    apply_colors(color_factor, color_additive);
    apply_transform(tr, depth);
    apply_entity_scale(make_vec(size.x * tr.scale, size.y * tr.scale));
    apply_uv(uv_offset, uv_scale);
    bind(tex);
    draw_elements(quad_db);
}

void draw_sprite(Transform2D tr, float32 depth, Sprite sprite) {
    draw_sprite(tr, depth, sprite, vec4_one, vec4_zero);
}

void draw_sprite(Transform2D tr, float32 depth, Sprite sprite, vec4 color_factor, color_additive) {
    draw_texture(tr, depth, sprite.sheet.texture, get_sprite_boundingbox(sprite), color_factor, color_additive);
}


vec2 get_mouse_world_coord(Transform2D cam_tr) {
    float32 x = mouse_x as float32 / app.window_width * 2 - 1;
    float32 y = -(mouse_y as float32 / app.window_height * 2 - 1);

    x *= app.width_over_height;

    return local2world(cam_tr, x, y);
}


struct Spritesheet {
    Image_Boundingbox* regions; // list
    Texture2D texture;
}

struct Sprite {
    Spritesheet* sheet;
    uint32 bb_index;
}

// TODO: this is a good idea. Should also just remove Spritesheet struct its not needed.
// struct Sprite {
//     vec2 uv_offset;
//     vec2 uv_scale;
//     uint32 tex;
// }

Image_Boundingbox get_sprite_boundingbox(Sprite sprite) return sprite.sheet.regions[sprite.bb_index];
ivec2 get_sprite_size(Sprite s) return get_boundingbox_size(get_sprite_boundingbox(s));

Sprite get_sprite(with Spritesheet* sheet, uint32 index) {
    Sprite s = {};
    s.sheet = sheet;
    s.bb_index = index;
    return s;
}



DrawBuffers quad_db;

Texture2D projectile;
Texture2D particle;

Spritesheet spritesheet;
Spritesheet spritesheet_items;

const sprites_asteroids_count = 3;
Sprite[3] sprites_asteroids;

Sprite[2] sprites_items;

Sprite sprite_turret;

// struct Assets {
//     Spritesheet spritesheet;
//     Spritesheet spritesheet_items;

//     Sprite[] sprites;

//     Sprite*[sprites_asteroids_count] asteroids;
//     Sprite*[] spaceships;
//     Sprite*[ItemKind_Count] items;
// }

void loadassets() {
    projectile = load_texture2D("assets/proj.bmp");
    particle   = load_texture2D("assets/particle.bmp");


    Spritesheet load_spritesheet(char* file_name) {
        let image = load_bitmap(file_name);
        Spritesheet sheet = {};

        sheet.texture = create_texture2D(image);
        set_filter(sheet.texture, TextureFilter.nearest);

        sheet.regions = get_all_regions(image);

        free(image.pixels);
        return sheet;
    }

    spritesheet = load_spritesheet("assets/spritesheet.bmp");
    spritesheet_items = load_spritesheet("assets/Items.bmp");

    for 0 .. spaceship_types.length {
        spaceship_types[it].sprite = get_sprite(*spritesheet, spaceship_types[it].sprite_index);
    }

    for 0 .. sprites_asteroids_count {
        sprites_asteroids[it] = get_sprite(*spritesheet, it);
    }

    for 0 .. ItemKind_Count {
        sprites_items[it] = get_sprite(*spritesheet_items, it);
    }

    sprite_turret = get_sprite(*spritesheet, 8);
}

void on_event(AppEvent event, AppEventData data) switch event {

}

void main() {
    grax_init();
    app.on_event = on_event;

    loadassets();

    quad_db = create_draw_buffers();
    {
        float32 p = 0.5;
        vertex2D[] verts = {
            {-p, -p, 0, 0, White},
            { p, -p, 1, 0, White},
            { p,  p, 1, 1, White},
            {-p,  p, 0, 1, White}
        };

        uint32[] inds = {
            0, 1, 2,
            0, 2, 3
        };
        update_buffers(*quad_db, verts, inds);
    }

    set_clear_color(rgba(0x0a0a0aff));

    while grax_loop() {
        use(*default2d_shader);
        enable_alpha_blending();
        enable_depth_test();

        update_world();

        draw_gui();

        this_frame = {};
    }
}

ThisFrameData this_frame;
struct ThisFrameData {
    bool player_pickup_item;
    bool player_took_damage;
}

struct Gui_Bar {
    vec4 color;
    float32 height;

    vec4 target_color;
    float32 target_height;

    float32 progress;
}

Gui_Bar bar_player_capacity;
Gui_Bar bar_player_health;

void draw_bar(Gui_Bar* bar, vec2 pos, float32 width) {
    Color bar_bg  = rgba(0xAA_AA_AA_A0);

    vec2 size  = { width, bar.target_height };
    vec2 size2 = { width * bar.progress, bar.height };

    anchor = .bottom_left;
    draw_rect(pos, size, bar_bg);
    draw_rect(pos, size2, rgba(bar.color));
    anchor = .center;

    let dt = deltatime();
    float32 rate = 10;
    bar.color = exp_decay(bar.color, bar.target_color, rate, dt);
    bar.height = exp_decay(bar.height, bar.target_height, rate, dt);
}

void draw_gui() {
    float32 height = 0.07;

    bar_player_capacity.target_color = color_to_vec4(rgba(0x10_60_E0_F0));
    bar_player_capacity.target_height = height;

    bar_player_health.target_color = color_to_vec4(rgba(0xFF_60_40_F0));
    bar_player_health.target_height = height;

    if this_frame.player_took_damage {
        bar_player_health.color = vec4_one;
        bar_player_health.height = height * 1.2;
    }

    if this_frame.player_pickup_item {
        bar_player_capacity.color = vec4_one;
        bar_player_capacity.height = height * 1.2;
    }

    if player {
        vec2 pos = app.bottom_left + make_vec(height, height);

        bar_player_capacity.progress = cargo_amount(player) / player.cargo_capacity as float32;
        draw_bar(*bar_player_capacity, pos, 1.0);

        pos.y += height * 1.5;

        bar_player_health.progress = player.hp / player.max_hp as float32;
        draw_bar(*bar_player_health, pos, 1.0);
    }
}