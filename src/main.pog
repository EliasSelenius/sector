
include "../grax/grax.pog";

include "src/world.pog";
include "src/particles.pog";
include "src/inventory.pog";

// ..\plang\bin\plang.exe src\main.pog cflags -lglfw3dll

/*
    Civilization is flourishing in an asteroid field of abundant riches, and yet conflict is prevalent
*/

/* TODOs:
    - thrusters effect
    - sub-particle trail for explosions
    - cargo inventory
        - asteroids drop minerals
        - ships drop cargo hold

    - we probably need transparancy sorting because how else do we do alpha blending with transparent objects/particles/dustclouds
Priority:
    - asteroids break into smaller asteroids





research audio implementations:
    - raylib source code
    - handmade hero?
        - direct sound
        - x audio
    - sokol audio

*/

void apply_camera(Transform2D t) {
    glUniform1f(glGetUniformLocation(default2d_shader.gl_handle, "zoom"), t.scale);
    glUniform2f(glGetUniformLocation(default2d_shader.gl_handle, "cam_pos"), t.pos.x, t.pos.y);
    glUniform1f(glGetUniformLocation(default2d_shader.gl_handle, "cam_rot"), t.rot);
}

void apply_transform(Transform2D t) { apply_transform(t, 0); }
void apply_transform(Transform2D t, float32 depth) {
    glUniform3f(glGetUniformLocation(default2d_shader.gl_handle, "entity_pos"), t.pos.x, t.pos.y, depth);
    glUniform1f(glGetUniformLocation(default2d_shader.gl_handle, "entity_rot"), t.rot);
    glUniform2f(glGetUniformLocation(default2d_shader.gl_handle, "entity_scale"), t.scale, t.scale);
}

void apply_color(vec4 v) {
    glUniform4f(glGetUniformLocation(default2d_shader.gl_handle, "color_factor"), v.x, v.y, v.z, v.w);
}

void apply_entity_scale(vec2 scale) {
    glUniform2f(glGetUniformLocation(default2d_shader.gl_handle, "entity_scale"), scale.x, scale.y);
}

void draw_texture(Transform2D tr, float32 depth, Texture2D tex, vec4 color) {
    apply_transform(tr, depth);
    apply_entity_scale(make_vec(tex.width * tr.scale, tex.height * tr.scale));
    apply_color(color);
    bind(tex);
    draw_elements(quad_db);
}

vec2 get_mouse_world_coord(Transform2D cam_tr) {
    float32 x = mouse_x as float32 / app.window_width * 2 - 1;
    float32 y = -(mouse_y as float32 / app.window_height * 2 - 1);

    x *= app.width_over_height;

    return local2world(cam_tr, x, y);
}



int32 global_seed = 0;

vec2 random_unit_vec2() {
    // return normalize(make_vec(random(global_seed++), random(global_seed++)));
    float32 a = random(global_seed++) * Pi;
    return { cosf(a), sinf(a) };
}
vec2 random_unit_vec2(float32 max_len) {
    return mul(random_unit_vec2(), max_len * (random(global_seed++) + 1.0) / 2.0);
}

float32 random01() { return (random(global_seed++) + 1.0) / 2.0; }

float32 random_range(int32 seed, float32 min, float32 max) {
    return lerp((random(seed) + 1.0) / 2.0, min, max);
}



DrawBuffers quad_db;

Texture2D spaceship;
Texture2D spaceship2;
Texture2D spaceship_from_internet;
Texture2D asteroid;
Texture2D projectile;
Texture2D particle;
Texture2D spritesheet;

void loadassets() {
    spaceship               = load_texture2D("assets/spaceship.bmp");
    spaceship2              = load_texture2D("assets/spaceship2.bmp");
    spaceship_from_internet = load_texture2D("assets/from_internet.bmp");
    asteroid                = load_texture2D("assets/asteroid.bmp");
    projectile              = load_texture2D("assets/proj.bmp");
    particle                = load_texture2D("assets/particle.bmp");


    let ss = load_spritesheet("assets/spritesheet.bmp");
    spritesheet = create_texture2D(ss.image);
    set_filter(spritesheet, TextureFilter.nearest);
    free(ss.image.pixels);
}

struct Spritesheet_Boundingbox {
    ivec2 min, max;
}

bool point_in_region(Spritesheet_Boundingbox bb, int32 x, y) {
    return x <= bb.max.x and x >= bb.min.x
       and y <= bb.max.y and y >= bb.min.y;
}

struct Spritesheet {
    Spritesheet_Boundingbox* regions; // list
    Image image;
}


Spritesheet_Boundingbox flood_fill(Image image, uint32 x, y) {
    bool* map = calloc(1, image.width * image.height * sizeof bool);

    /* TODO: idea:
        since we only care about the boundingbox, we could try a different flood fill
        where we 'expand' the boundingbox and only recurse on the pixels that borders the boundingbox.
        this may also remove the necessity of the 'map' buffer
        might be faster, should benchmark...

        wait is this what is called boundary fill?

        start with 1x1 boundingbox at starting pixel
        foreach of the 4 borders of the boundingbox
            foreach pixel of border
                if pixel is non-background
                    expand boundingbox in direction of pixel
                    break out of pixel loop
    */

    Spritesheet_Boundingbox bb = {
        min = {image.width, image.height},
        max = {0, 0}
    };

    void rec(Spritesheet_Boundingbox* bb, bool* map, Image image, uint32 x, y) {
        if x >= image.width or y >= image.height  return;

        if map[y * image.width + x]       return;
        if get_pixel(image, x, y).a == 0  return;

        map[y * image.width + x] = true;

        bb.min = min(bb.min, make_ivec(x as int32, y as int32));
        bb.max = max(bb.max, make_ivec(x as int32, y as int32));

        rec(bb, map, image, x + 1, y);
        rec(bb, map, image, x - 1, y);
        rec(bb, map, image, x, y + 1);
        rec(bb, map, image, x, y - 1);

        const eight_way = true;
        if eight_way {
            rec(bb, map, image, x + 1, y + 1);
            rec(bb, map, image, x - 1, y - 1);
            rec(bb, map, image, x - 1, y + 1);
            rec(bb, map, image, x + 1, y - 1);
        }
    }

    rec(*bb, map, image, x, y);
    free(map);
    return bb;
}

Spritesheet load_spritesheet(char* file_name) {
    return load_spritesheet(load_bitmap(file_name));
}

Spritesheet load_spritesheet(Image image) {
    Spritesheet ss = {};
    ss.image = image;
    ss.regions = list_create(sizeof Spritesheet_Boundingbox);

    for uint32 y : 0 .. image.height {
        for uint32 x : 0 .. image.width {
            Color pixel = get_pixel(image, x, y);
            if pixel.a == 0  continue;

            for 0 .. list_length(ss.regions) if point_in_region(ss.regions[it], x as int32, y as int32) {
                x = (ss.regions[it].max.x + 1) as uint32; // skip pixels we know are in the region
                goto next;
            }

            let bb = flood_fill(image, x, y);
            list_add(*ss.regions, *bb);
            x = (bb.max.x + 1) as uint32; // skip pixels we know are in the region
            next:
        }
    }

    for 0 .. list_length(ss.regions) {
        let bb = ss.regions[it];

        ivec2 size = sub(bb.max, bb.min);
        size = add(size, ivec2_one);
        print("pos = ", bb.min, "\nsize = ", size, "\n");
    }

    return ss;
}


Transform2D camera = {0,0, 0, 10};


void main() {


    // {
    //     float32 x = 0;
    //     for 0 .. 100 {
    //         print(x, " -> ", round2multiple(x, 3), "\n");
    //         x += 0.1;
    //     }
    //     return;
    // }


    grax_init();

    loadassets();

    quad_db = create_draw_buffers();
    {
        float32 p = 0.5;
        vertex2D[] verts = {
            {-p, -p, 0, 0, White},
            { p, -p, 1, 0, White},
            { p,  p, 1, 1, White},
            {-p,  p, 0, 1, White}
        };

        uint32[] inds = {
            0, 1, 2,
            0, 2, 3
        };
        update_buffers(*quad_db, verts, inds);
    }

    let player = spawn_entity(*global_entity_pool, vec2_zero, spaceship2);
    player.hp = player_max_hp;
    player.team_id = 0;

    set_clear_color(rgba(0x0a0a0aff));

    while grax_loop() {
        drawframe();
    }
}


void drawframe() {
    use(*default2d_shader);
    enable_alpha_blending();
    enable_depth_test();

    let player = get_player();

    camera.pos = lerp(0.1, camera.pos, player.tr.pos);
    camera.scale = 10 + length(player.vel) / 10;
    apply_camera(camera);


    vec2 mouse_world_pos = get_mouse_world_coord(camera);

    if mouse_pressed(Right_Mouse) {
        let e = spawn_entity(*global_entity_pool, mouse_world_pos, spritesheet);
        // let e = spawn_enemy(mouse_world_pos);
        e.vel = mul(make_vec((mouse_x - pmouse_x) as float32, -(mouse_y - pmouse_y) as float32), 0.01);
    }



    { // update player
        thrust(player, wasd);
        turn_to(player, mouse_world_pos);
        if mouse(Left_Mouse) fire_gun(player);
        if entity_is_dead(@player) {
            player.hp = player_max_hp;
            player.tr.pos = vec2_zero;
        }

        const font_size = 0.1;
        vec2 pos = {-1, 1 - font_size / 2};
        pos = draw_text(pos, font_size, to_string(player.hp as uint64), White);
        pos = draw_text(pos, font_size, " / ", White);
        pos = draw_text(pos, font_size, to_string(player_max_hp), White);
    }

    update_entities();
}
