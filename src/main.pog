
include "../grax/grax.pog";

include "src/world.pog";
include "src/particles.pog";
include "src/inventory.pog";
include "src/agent.pog";

// ..\plang\bin\plang.exe src\main.pog cflags -lglfw3dll
// ..\plang\bin\plang.exe src\main.pog cflags -lglfw3dll -O0 -g -fsanitize=address -fno-omit-frame-pointer

/*
    Civilization is flourishing in an asteroid field of abundant riches, and yet conflict is prevalent
*/

/* TODOs:
    - we probably need transparancy sorting because how else do we do alpha blending with transparent objects/particles/dustclouds
    - dust particles floating in space
    - several layers of fog/dust in background
    - asteroid cluster distribution
    - bullet impact particles

    - smoke particle on damaged ships
    - electric particle effect on damaged ships

Priority:
    - spacestation
    - drop cargo at spacestation -> cargo turns into money -> money buys bigger ships

    - improve AI
        - detection range
        - passive behaviour
            - pickup items
            - destroy asteroid
            - drop cargo at spacestation
            - follow behaviour fleet leader

        - aggressive when provoked
            - loose aggression

    - seperate rendering and game logic into different codepaths
        - render map


research audio implementations:
    - raylib source code
    - handmade hero?
        - direct sound
        - x audio
    - sokol audio

*/

void apply_camera(Transform2D t) {
    set_uniform("zoom", t.scale);
    set_uniform("cam_pos", t.pos.x, t.pos.y);
    set_uniform("cam_rot", t.rot);
}

void apply_transform(Transform2D t) { apply_transform(t, 0); }
void apply_transform(Transform2D t, float32 depth) {
    set_uniform("entity_pos", t.pos.x, t.pos.y, depth);
    set_uniform("entity_rot", t.rot);
    set_uniform("entity_scale", t.scale, t.scale);
}

void apply_colors(vec4 factor, additive) {
    set_uniform("color_factor", factor);
    set_uniform("color_additive", additive);
}

void apply_entity_scale(vec2 scale) {
    set_uniform("entity_scale", scale);
}

void apply_uv(vec2 uv_offset, uv_scale) {
    set_uniform("uv_offset", uv_offset);
    set_uniform("uv_scale", uv_scale);
}

void draw_texture(Transform2D tr, float32 depth, Texture2D tex, vec4 color_factor, color_additive) {
    draw_texture(quad_db, tr, depth, tex, vec2_zero, vec2_one, color_factor, color_additive);
}

void draw_texture(Transform2D tr, float32 depth, Texture2D tex, Image_Boundingbox bb, vec4 color_factor, color_additive) {
    draw_texture(quad_db, tr, depth, tex, bb, color_factor, color_additive);
}

void draw_texture(DrawBuffers db, Transform2D tr, float32 depth, Texture2D tex, Image_Boundingbox bb, vec4 color_factor, color_additive) {
    vec2 uv_offset = {};
    vec2 uv_scale = {};
    ivec2 size = get_boundingbox_size(bb);
    uv_scale.x = size.x / tex.width as float32;
    uv_scale.y = size.y / tex.height as float32;
    uv_offset.x = bb.min.x / tex.width as float32;
    uv_offset.y = bb.min.y / tex.height as float32;

    draw_texture(db, tr, depth, tex, uv_offset, uv_scale, color_factor, color_additive);
}

void draw_texture(DrawBuffers db, Transform2D tr, float32 depth, Texture2D tex, vec2 uv_offset, uv_scale, vec4 color_factor, color_additive) {
    apply_colors(color_factor, color_additive);
    apply_transform(tr, depth);
    apply_entity_scale(uv_scale * make_vec(tex.width, tex.height) * tr.scale);
    apply_uv(uv_offset, uv_scale);
    bind(tex);
    draw_elements(db);
}




void draw_sprite(Transform2D tr, float32 depth, Sprite sprite) {
    draw_sprite(tr, depth, sprite, vec4_one, vec4_zero);
}

void draw_sprite(DrawBuffers db, Transform2D tr, float32 depth, Sprite sprite, vec4 color_factor, color_additive) {
    draw_texture(db, tr, depth, sprite.tex, sprite.uv_offset, sprite.uv_scale, color_factor, color_additive);
}

void draw_sprite(Transform2D tr, float32 depth, Sprite sprite, vec4 color_factor, color_additive) {
    draw_texture(quad_db, tr, depth, sprite.tex, sprite.uv_offset, sprite.uv_scale, color_factor, color_additive);
}


vec2 get_mouse_world_coord(Transform2D cam_tr) {
    float32 x = mouse_x as float32 / app.window_width * 2 - 1;
    float32 y = -(mouse_y as float32 / app.window_height * 2 - 1);

    x *= app.width_over_height;

    return local2world(cam_tr, x, y);
}


struct Spritesheet {
    Image_Boundingbox* regions; // list
    Texture2D texture;
}

struct Sprite {
    vec2 uv_offset;
    vec2 uv_scale;
    Texture2D tex;
}

Sprite get_sprite(with Spritesheet* sheet, uint32 index) {
    Sprite s = {};
    s.tex = sheet.texture;

    let bb = sheet.regions[index];
    ivec2 size = get_boundingbox_size(bb);
    s.uv_scale.x = size.x / s.tex.width as float32;
    s.uv_scale.y = size.y / s.tex.height as float32;
    s.uv_offset.x = bb.min.x / s.tex.width as float32;
    s.uv_offset.y = bb.min.y / s.tex.height as float32;

    return s;
}

Sprite make_sprite(Texture2D tex) {
    return { uv_offset = vec2_zero, uv_scale = vec2_one, tex = tex };
}

ivec2 get_sprite_pixel_size(Sprite s) {
    return make_ivec(s.uv_scale * make_vec(s.tex.width, s.tex.height));
}

DrawBuffers quad_db;
const debris_count = 6;
DrawBuffers[debris_count] db_debris;


Spritesheet spritesheet;
Spritesheet spritesheet_items;

const sprites_asteroids_count = 3;
Sprite[3] sprites_asteroids;

Sprite[2] sprites_items;

Sprite sprite_turret;
Sprite sprite_spacestation;

Texture2D projectile;
Texture2D particle;
Sprite sprite_projectile;
Sprite sprite_particle;

// struct Assets {
//     Spritesheet spritesheet;
//     Spritesheet spritesheet_items;

//     Sprite[] sprites;

//     Sprite*[sprites_asteroids_count] asteroids;
//     Sprite*[] spaceships;
//     Sprite*[ItemKind_Count] items;
// }

void loadassets() {
    projectile = load_texture2D("assets/proj.bmp");
    particle   = load_texture2D("assets/particle.bmp");

    set_filter(particle, TextureFilter.linear);
    // set_wrap_mode(particle, TextureWrapMode.clamp_to_edge);

    Spritesheet load_spritesheet(char* file_name) {
        let image = load_bitmap(file_name);
        Spritesheet sheet = {};

        sheet.texture = create_texture2D(image);
        set_filter(sheet.texture, TextureFilter.nearest);

        sheet.regions = get_all_regions(image);

        free(image.pixels);
        return sheet;
    }

    spritesheet = load_spritesheet("assets/spritesheet.bmp");
    spritesheet_items = load_spritesheet("assets/Items.bmp");

    for 0 .. spaceship_types.length {
        spaceship_types[it].sprite = get_sprite(*spritesheet, spaceship_types[it].sprite_index);
    }

    for 0 .. sprites_asteroids_count {
        sprites_asteroids[it] = get_sprite(*spritesheet, it);
    }

    for 0 .. ItemKind_Count {
        sprites_items[it] = get_sprite(*spritesheet_items, it);
    }

    sprite_turret = get_sprite(*spritesheet, 9);
    sprite_spacestation = get_sprite(*spritesheet, 15);

    sprite_projectile = make_sprite(projectile);
    sprite_particle = make_sprite(particle);
}

void on_event(AppEvent event, AppEventData data) switch event {

}

void main() {
    grax_init();
    app.on_event = on_event;

    loadassets();

    quad_db = create_draw_buffers(sizeof vertex2D, vertex2D_attribs);
    {
        float32 p = 0.5;
        vertex2D[] verts = { {-p, -p, 0, 0, White},
                             { p, -p, 1, 0, White},
                             { p,  p, 1, 1, White},
                             {-p,  p, 0, 1, White} };

        uint32[] inds = { 0, 1, 2,
                          0, 2, 3 };

        update_buffers(*quad_db, verts, inds);
    }

    for 0 .. debris_count {
        db_debris[it] = create_draw_buffers(sizeof vertex2D, vertex2D_attribs);

        vec2 clamp_to_square_edge(float32 x, y) {
            if abs(x) < abs(y) {
                y /= abs(y);
            } else {
                x /= abs(x);
            }

            return make_vec(x, y) * 0.5;
        }

        vertex2D[3] vs;
        vs[0] = {0, 0, 0.5, 0.5, White};

        let t = it as float32 / debris_count * Tau;
        vec2 p = clamp_to_square_edge(cos(t), sin(t));
        vs[1] = {p, p + vec2_one*0.5, White};

        t = (it+1) as float32 / debris_count * Tau;
        p = clamp_to_square_edge(cos(t), sin(t));
        vs[2] = {p, p + vec2_one*0.5, White};

        uint32[] inds = { 0, 1, 2 };
        vertex2D[] verts;
        verts.data = *vs;
        verts.length = 3;
        update_buffers(*db_debris[it], verts, inds);
    }

    set_clear_color(rgba(0x0a0a0aff));

    while grax_loop() {
        use(*default2d_shader);
        enable_alpha_blending();
        enable_depth_test();

        update_world();

        draw_gui();

        this_frame = {};
    }
}

ThisFrameData this_frame;
struct ThisFrameData {
    bool player_pickup_item;
    bool player_took_damage;
}

struct Gui_Bar {
    vec4 color;
    float32 height;

    vec4 target_color;
    float32 target_height;

    float32 progress;
}

Gui_Bar bar_player_capacity;
Gui_Bar bar_player_health;

void draw_bar(Gui_Bar* bar, vec2 pos, float32 width) {
    Color bar_bg  = rgba(0xAA_AA_AA_A0);

    vec2 size  = { width, bar.target_height };
    vec2 size2 = { width * bar.progress, bar.height };

    anchor = .bottom_left;
    draw_rect(pos, size, bar_bg);
    draw_rect(pos, size2, rgba(bar.color));
    anchor = .center;

    let dt = deltatime();
    float32 rate = 10;
    bar.color = exp_decay(bar.color, bar.target_color, rate, dt);
    bar.height = exp_decay(bar.height, bar.target_height, rate, dt);
}

void draw_gui() {
    float32 height = 0.07;

    bar_player_capacity.target_color = color_to_vec4(rgba(0x10_60_E0_F0));
    bar_player_capacity.target_height = height;

    bar_player_health.target_color = color_to_vec4(rgba(0xFF_60_40_F0));
    bar_player_health.target_height = height;

    if this_frame.player_took_damage {
        bar_player_health.color = vec4_one;
        bar_player_health.height = height * 1.2;
    }

    if this_frame.player_pickup_item {
        bar_player_capacity.color = vec4_one;
        bar_player_capacity.height = height * 1.2;
    }

    if player {
        vec2 pos = app.bottom_left + make_vec(height, height);

        bar_player_capacity.progress = cargo_amount(player) / player.cargo_capacity as float32;
        draw_bar(*bar_player_capacity, pos, 1.0);

        pos.y += height * 1.5;

        bar_player_health.progress = player.hp / player.max_hp;
        draw_bar(*bar_player_health, pos, 1.0);
    }
}