

// struct QuadTreeNode {
//     QuadTreeNode* q1, q2, q3, q4;
//     Entity* e;
// }

// QuadTreeNode* insert(QuadTreeNode* node, vec2 pos, float32 size, Entity* e) {
//     if node == null  node = alloc QuadTreeNode;
//     if node.e {
//     }
//     node.e = e;
// }




const linear_drag = 0.99;

// TODO: definitely should use arena for entity pools so we dont have to worry about reference invalidation due to list resize
Entity* global_entity_pool = list_create(sizeof Entity);
Entity* get_player() { return *global_entity_pool[0]; }

const player_max_hp = 200;

Bullet* bullets = list_create(sizeof Bullet);
Particle* particles = list_create(sizeof Particle);


struct Entity {
    void(Entity*) behaviour;

    with Transform2D tr;
    float32 depth;

    Texture2D texture;

    vec2 vel;
    float32 ang_vel;

    uint32 hp;
    uint32 team_id;
    float32 gun_recharge;
}

struct Bullet {
    vec2 pos;
    vec2 vel;
    uint32 team_id;
}

struct Particle {
    vec2 pos;
    float32 rot;
    vec2 vel;
    Texture2D tex;
    float32 life_time;
}


void spawn_bullet(vec2 pos, vec2 vel, uint32 team_id) {
    Bullet p = {pos, vel, team_id};
    list_add(*bullets, *p);
}

void spawn_particle(vec2 pos, vec2 vel, Texture2D tex) {
    Particle p = {};
    p.pos = pos;
    p.vel = vel;
    p.rot = random(global_seed++) * Pi;
    p.tex = tex;
    p.life_time = random01() * 2.5;
    list_add(*particles, *p);
}

void spawn_explosion(uint32 size, vec2 pos, vel, float32 spread) {
    for 0 .. size {
        vec2 r = random_unit_vec2(spread);
        spawn_particle(pos, add(vel, r), particle);
    }
}

void draw_particles() {
    let dt = deltatime as float32;
    let count = list_length(particles);
    for 0 .. count {
        let p = *particles[it];
        p.pos = add(p.pos, mul(p.vel, dt));
        p.vel = mul(p.vel, random_range(it, 0.96, 1));
        p.life_time -= dt;

        const fire_color = {1, 173.0 / 255.0, 10.0 / 255.0} as vec3;
        const smoke_color = {64.0 / 255.0, 64.0 / 255.0, 64.0 / 255.0} as vec3;
        vec4 color = make_vec(lerp(p.life_time, smoke_color, fire_color), p.life_time);
        Transform2D tr = {p.pos, p.rot, 1.0 / 16.0};
        draw_texture(tr, 0, p.tex, color);

        if p.life_time < 0  list_unordered_remove(particles, it as uint32); // TODO: fix this remove in iterator
    }
}

void kill_entity(Entity* e) { e.hp = 0; }
bool entity_is_dead(Entity e) { return e.hp == 0; }

Entity* spawn_entity(Entity** pool, vec2 pos, Texture2D tex) {
    Entity* e = list_append(pool);

    @e = {};
    e.tr.pos = pos;
    e.tr.rot = 0;
    e.tr.scale = 1.0 / 16.0;
    e.depth = 0;
    e.hp = 8;
    e.texture = tex;

    return e;
}

void accelerate(Entity* e, vec2 acc) {
    e.vel = add(e.vel, mul(acc, deltatime as float32));
}

// note: |dir.x| <= 1 and |dir.y| <= 1
void thrust(Entity* e, vec2 dir) {
    const non_forward_factor = 0.5;

    dir.x *= non_forward_factor;
    if dir.y < 0  dir.y *= non_forward_factor;

    dir = mul(dir, 5);

    accelerate(e, rotate_vec(dir, e.tr.rot));
}

void turn_to(Entity* e, vec2 target) {
    let diff = sub(target, e.tr.pos);
    diff = rotate_vec(diff, -e.tr.rot);
    float32 angle = vec2_to_angle(diff);

    e.ang_vel = angle * 3;
}

void fire_gun(Entity* e) {
    if e.gun_recharge <= 0 {
        let disp = up(e.tr);
        disp.x *= -1;
        let v = add(mul(disp, 50), e.vel);
        const spread = 3;
        v = add(v, random_unit_vec2(spread));
        spawn_bullet(add(e.tr.pos, disp), v, e.team_id);
        e.gun_recharge = 0.25;
    }
}

Entity* spawn_enemy(vec2 pos) {
    static uint32 ships_index = 0;
    Texture2D[] ships = {
        spaceship,
        spaceship2,
        spaceship_from_internet
    };

    let e = spawn_entity(*global_entity_pool, pos, ships[ships_index++ % ships.length]);
    e.tr.rot = random(global_seed++) * Pi;
    e.team_id = 1;
    e.behaviour = update_ai;
    return e;
}

void update_entity(Entity* e) {
    e.tr.pos = add(e.tr.pos, mul(e.vel, deltatime as float32));
    e.tr.rot += e.ang_vel * deltatime as float32;
    e.vel = mul(e.vel, linear_drag);
    // e.ang_vel *= 0.99;

    e.gun_recharge -= deltatime as float32;

    vec4 color = vec4_one;

    for 0 .. list_length(bullets) {
        let p = bullets[it];
        if p.team_id == e.team_id continue;

        float32 intersection = circle_intersects(e.tr.pos, e.texture.width * e.tr.scale / 2, p.pos, 0.3);
        if intersection < 0 {
            color = {100, 100, 100, 0};
            e.hp--;
            e.vel = add(e.vel, mul(p.vel, 0.004));
            list_unordered_remove(bullets, it as uint32);
            it--;

            if e.hp == 0 {
                spawn_explosion(e.texture.width + e.texture.height, e.tr.pos, e.vel, 7);
                break;
            }
        }
    }

    draw_texture(e.tr, e.depth, e.texture, color);

    if e.behaviour  e.behaviour(e);
}

void update_ai(Entity* e) {

    turn_to(e, get_player().tr.pos);
    let dist = length(sub(e.tr.pos, get_player().tr.pos));

    if dist < 15  fire_gun(e);

    let t = dist - 5;
    t = t / abs(t);
    thrust(e, { 0, t } as vec2);
}

float32 circle_intersects(vec2 p0, float32 r0, vec2 p1, float32 r1) {
    let len = length(sub(p0, p1));
    let r = r0 + r1;
    return len - r;
}


void update_entities() {

    draw_background(camera.pos);

    ivec2 chunk_coord = get_chunk_coord(get_player().tr.pos);

    const bot_left = 0;
    const bot_right = 1;
    const top_left = 2;
    const top_right = 3;
    ivec2[] chunk_coord_offsets = { {0, 0}, {1, 0}, {0, 1}, {1, 1} };
    Chunk*[] chunks = {*chunk_1, *chunk_2, *chunk_3, *chunk_4};
    int32 coord_index = 0;
    ivec2[] coords = {{},{},{},{}};

    for it : 0 .. 4 {
        ivec2 coord = add(chunk_coord, chunk_coord_offsets[it]);

        if      equals(coord, chunk_1.coord) { chunks[0] = null; continue; }
        else if equals(coord, chunk_2.coord) { chunks[1] = null; continue; }
        else if equals(coord, chunk_3.coord) { chunks[2] = null; continue; }
        else if equals(coord, chunk_4.coord) { chunks[3] = null; continue; }
        else {
            coords[coord_index++] = coord;
        }
    }

    coord_index = 0;
    for 0 .. chunks.length {
        if chunks[it] == null  continue;

        spawn_chunk(chunks[it], coords[coord_index++]);
    }



    void update_entity_list(Entity* ens) {
        for 0 .. list_length(ens) {
            let e = *ens[it];
            if entity_is_dead(@e) continue;
            update_entity(e);
        }
    }

    update_entity_list(global_entity_pool);
    update_entity_list(chunk_1.entities);
    update_entity_list(chunk_2.entities);
    update_entity_list(chunk_3.entities);
    update_entity_list(chunk_4.entities);



    bind(projectile);
    for 0 .. list_length(bullets) {
        let p = *bullets[it];

        const despawn_radius = 400;
        if sqdist(get_player().tr.pos, p.pos) > (despawn_radius*despawn_radius) {
            list_unordered_remove(bullets, it as uint32);
            it--;
            continue;
        }

        Transform2D tr = { p.pos, vec2_to_angle(p.vel), 0.1 };
        apply_transform(tr);

        vec2 particle_scale = {0.25, 1}; // TODO: hard coded dimentions here
        apply_entity_scale(particle_scale);
        draw_elements(quad_db);

        p.pos = add(p.pos, mul(p.vel, deltatime as float32));
    }


    static uint32 prev_bullets_count = 0;
    uint32 bullets_count = list_length(bullets);
    if bullets_count != prev_bullets_count {
        // print("Bullets: ", bullets_count, "\n");
        prev_bullets_count = bullets_count;
    }


    disable_depth_test();
    draw_particles();
}

void draw_background(vec2 center) {
    const s = 10;
    const spacing = 10;
    for x : -s .. s+1 for y : -s .. s+1 {
        ivec2 p_seed = make_ivec(round2multiple(center, spacing));
        p_seed.x += x * spacing; p_seed.y += y * spacing;

        int32 seed = p_seed.x + p_seed.y * 100;

        float32 depth = map(random(seed++), -1, 1, 0.3, 1.0);
        Transform2D tr = {};
        tr.pos = add(make_vec(p_seed), mul(make_vec(random(seed++), random(seed++)), spacing / 2.0));
        tr.rot = random(seed++) * Pi;
        tr.scale = asteroid.width as float32 / 16.0;

        apply_transform(tr, depth);
        apply_color(vec4_one);
        bind(asteroid);
        draw_elements(quad_db);
    }
}

const chunk_size = 100;

Chunk chunk_1 = init_chunk();
Chunk chunk_2 = init_chunk();
Chunk chunk_3 = init_chunk();
Chunk chunk_4 = init_chunk();


struct Chunk {
    ivec2 coord;
    Entity* entities;
}

ivec2 get_chunk_coord(vec2 pos) {
    return make_ivec(mul(round2multiple(pos, chunk_size), 1.0 / chunk_size));
}

Chunk init_chunk() {
    Chunk s = {};
    s.coord = {999, 999}; // NOTE: this is to fix bug where chunk 0,0 wont generate at game start
    s.entities = list_create(sizeof Entity);
    return s;
}

void spawn_chunk(Chunk* chunk, ivec2 coord) {
    chunk.coord = coord;
    list_clear(chunk.entities);

    int32 seed = (coord.x & 0x0000FFFF) |
                ((coord.y << 16) & 0xFFFF0000);

    print("spawn chunk ", coord, " with seed: ", seed, "\n");

    const half = chunk_size / 2;
    vec2 chunk_pos = make_vec(sub(mul(coord, chunk_size), { half, half } as ivec2));

    const asteroids_per_square_meter = 0.01;

    // init interactable asteroids
    for 0 .. asteroids_per_square_meter * chunk_size * chunk_size {
        vec2 pos = { random(seed++) * half, random(seed++) * half };
        let e = spawn_entity(*chunk.entities, add(pos, chunk_pos), asteroid);
        e.tr.rot = random(seed++) * Pi;
        e.team_id = 2;
        e.hp = 10;
        e.depth = 0.01;
    }


    if random(global_seed++) < 0 {
        vec2 pos = { random(seed++) * half, random(seed++) * half };
        spawn_enemy(add(pos, chunk_pos));
    }
}